.. currentmodule:: edzed

======
Events
======

Events play a key role in sequential blocks' operation.

Events may be generated internally by circuit blocks or may originate from
external systems and be forwarded through some input interface.

An event is a message addressed to its destination block. It has
a :ref:`type<Event types>` and can carry arbitrary :ref:`data<Event data format>`.
The type is usually a string; the data consists of ``'name':<value>`` pairs.

Every block (even a combinational one) can generate events on its output change.
These are the most common events and are defined with an *on_output* argument.
Several sequential blocks can generate events also on certain internal state
changes.

By convention all parameters instructing a block to send events in certain
situations have names starting with an ``"on_"`` prefix and they accept:

- ``None`` meaning no events (an empty list or tuple has the same effect), or
-  a single :class:`Event` object, or
-  multiple (zero or more) :class:`Event` objects given as a sequence (tuple, list, ...)
   of single events.

Hence, the type annotation is: ``None | Event | Sequence[Event]``.

.. versionchanged:: 23.2.14

  Using an iterator to specify multiple events is deprecated.
  Use a tuple or a list instead.

The :class:`Event` instance sets the destination and the event type. New data
is added each time the event is sent.

For example, this code instructs the ``block1`` to send a ``put`` event
to ``block2`` each time when its output value changes. This creates a logical
link from ``block1`` to ``block2``::

  edzed.Input('block1', initdef=0, on_output=edzed.Event(block2, 'put'))

When the output changes say from ``23`` to ``27``, the source ``block1`` executes
following code in order to deliver the event::

  # fixed destination (block2) and type ('put')
  block2.event(
    'put',
    # current data for this event
    previous=23, value=27, source='block1', trigger='output')

When the output later changes again, the event will be delivered with different
values for ``'previous'`` and ``'value'`` items.


Event objects
=============

.. class:: Event(dest: str|Block, etype: str|EventType = 'put', efilter=None, repeat=None, count=None)

  Create an object with event settings. Mandatory settings are
  the :ref:`type<Event types>` *etype* and the destination block *dest*.

  A source block uses this ``Event`` object to send a new event each time some trigger
  condition is satisfied. Every such event is then a combination of fixed settings
  from the ``Event`` object and variable data specific to the particular event.

  The *dest* argument may be a sequential block object or its name.

  :ref:`Event filters` are functions (*callables* to be exact) documented below.
  The *efilter* argument may be:

  - ``None`` meaning no filters (an empty list or tuple has the same effect), or
  - a single function, or
  - a tuple, list or other sequence of functions.

  If a repeat interval is given with the *repeat* parameter, a :class:`Repeat` block
  is automatically created to repeat the event. This::

      edzed.Event(dest, etype, repeat=INTERVAL, count=COUNT)  # count is optional

  is equivalent to::

      edzed.Event(
        edzed.Repeat(
          None,
          comment="<auto-generated comment>",
          dest, etype, interval=INTERVAL, count=COUNT),
        etype)

  The *count* argument is valid only with the *repeat* argument.

  .. method:: abort() -> Event
    :classmethod:

    A shortcut for ``edzed.Event('_ctrl', 'abort')``.

    Specify an event addressed to circuit's :class:`ControlBlock`
    with an instruction to abort the simulation due to an error.

  .. method:: shutdown() -> Event
    :classmethod:

    A shortcut for ``edzed.Event('_ctrl', 'shutdown')``

    Specify an event addressed to circuit's :class:`ControlBlock`
    with an instruction to shut down the simulation.


Event types
===========

A simple name (string) is commonly used to identify the event type.

Occasionally a string is not suitable to fully identify
more complex events. For those few cases we use event type objects
instead of names.

.. class:: EventType

  The base class for all special events.

There is only one such event type for general use.
It's the conditional event simplifying the block-to-block event delivery:

.. class:: EventCond(etrue: str|EventType|None, efalse: str|EventType|None)

  A conditional event type, roughly equivalent to::

    etype = etrue if value else efalse

  where the ``value`` is taken from the event data item ``'value'``.
  Missing ``value`` is evaluated as ``False``, i.e. ``efalse`` is selected.
  ``None`` as *etrue* or *efalse* means no event in that case.


Event data format
=================

The event data form a Python dict, i.e. they consist of ``'name': <value>`` pairs.
The keys (names) must be strings and valid Python identifiers, because the data
items are passed to functions as keyword arguments. Best practice is to use
only ASCII letters ``a-z``, ``A-Z``, digits ``0-9`` and the ``_`` (underscore).


Event filters
=============

Event filters serve two purposes. As the name suggests, they can filter out
an event, i.e. cancel its delivery. The second use is to modify the filter data.

An event filter function is called with the event data as a single dictionary
as its sole argument.

- If it returns a :class:`dict` (precisely a :class:`MutableMapping`), the event is
  accepted and the returned dict becomes the new event data.

- If the function returns anything else than a dict instance,
  the event will be accepted or rejected depending on the boolean value
  of the returned value (true = accept, false (e.g. ``False`` or ``None``) = reject).

Event filters may modify the event data in-place.

Multiple filters are called in their definition order like a *pipeline*.

Event filters are usually very simple, often an "one-liner" or a ``lambda``
is all it takes.

.. seealso:: :ref:`List of event filters`


Output events
=============

There are two ways of specifying output events. The most common option *on_output*
is supported by all blocks. The specialized *on_every_output* is available to
sequential blocks only.

- events defined with the *on_output* parameter:

  These events are sent when the output value of the source block changes.

- events defined with the *on_every_output* parameter:

  Similar to *on_output*, but events are triggered each time the output is set,
  even if the new value is the same as the previous one.
  This is useful if the destination block should not miss a value (e.g. a measurement)
  just because it happens to be the same as the previous one.

In both cases the generated events are sent with these data items:

- ``'previous'``: previous value (:const:`UNDEF` on first change after initialization)
- ``'value'``: current output value
- ``'source'``: sender's block name (string, added automatically)
- ``'trigger'``: ``'output'`` (corresponds with ``'on_output'``)


Receiving events
================

Application code transfers data from an external system to the circuit by sending
events which the circuit receives. Internal events originate from other circuit blocks.

In both cases events are delivered by calling the :meth:`SBlock.event` method
of the destination block.

.. method:: SBlock.event(etype: str|EventType, /, **data) -> Any

  Handle the event of :ref:`type<Event types>` *etype* with attached *data*.
  Raise :exc:`EdzedUnknownEvent` if the *etype* is not supported.

  In particular, update the internal state and set the output value
  according to the block's rules.

  ``event()`` may return a value of any type. Other blocks ignore the returned
  value, but it may be useful for input interfaces to external systems.

  Accepted event types together with required data and returned values for each
  supported event type are part of the API for each particular block type.
  A block must ignore any additional data items.

  .. warning::

    If an exception (other than an unknown event type or a trivial parameter error)
    is raised during event handling, the simulation will be aborted even if
    the caller catches the exception with a ``try-event()-except`` construct.

.. method:: SBlock.put(value: Any, **data) -> Any

  This is a shortcut for the frequently used ``event('put', value=value, ...)``.
